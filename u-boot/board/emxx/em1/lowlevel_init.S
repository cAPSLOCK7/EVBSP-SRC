/*
 * Board specific setup info
 *
 * (C) Copyright 2007, 2008
 * NEC Electronics Corporation.
 *
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */

#include <config.h>
#include <version.h>

#include <asm/arch/em1.h>
#include <asm/arch/boot.h>
#include "reg.h"
#include "lowlevel_init_val.h"
#include "spi.h"

#if !defined(EMXX_MINIBOOT)
_TEXT_BASE:
	.word	TEXT_BASE	/* sdram load addr from config.mk */
#endif

_delay:
	sub	r7, r7, #1
	cmp	r7, #0
	bne	_delay
	mov	pc, lr

.globl lowlevel_init
lowlevel_init:
#if !(defined(CONFIG_EMXX_EMMCBOOT) || defined(CONFIG_EMXX_SDBOOT))
	/* Set up the stack */
	ldr	r3, =SRAM_STACK_BASE
	sub	sp, r3, #12		/* leave 3 words for abort-stack */
#endif

	mov	r9, lr

#if !(defined(CONFIG_EMXX_EMMCBOOT) || defined(CONFIG_EMXX_SDBOOT)) || defined(EMXX_MINIBOOT)
	/* Setting L1 HOLD */
	SET_BASEREG(r3, CHG_BASE)
	STORE_WORD(r3, CHG_L1_HOLD, CHG_L1_HOLD_VAL, r1)

	/* Set form POWER ON MODE to NORMAL MODE */
	SET_BASEREG(r0, ASMU_S0_BASE)

	STORE_WORD(r0, ASMU_PLL1CTRL0, ASMU_PLL1CTRL0_VAL, r1)
	STORE_WORD(r0, ASMU_PLL1CTRL1, ASMU_PLL1CTRL1_VAL, r1)
	STORE_WORD(r0, ASMU_NORMALA_DIV, ASMU_NORMALA_DIV_VAL, r1)
	STORE_WORD(r0, ASMU_NORMALB_DIV,  ASMU_NORMALB_DIV_VAL, r1)

	/* Initialize GIO port type */
	SET_BASEREG(r2, GIO_BASE)

	STORE_WORD(r2, GIO_OL_L, GIO_OL_L_VAL, r1)
	STORE_WORD(r2, GIO_OH_L, GIO_OH_L_VAL, r1)
	STORE_WORD(r2, GIO_E0_L, GIO_E0_L_VAL, r1)
	STORE_WORD(r2, GIO_E1_L, GIO_E1_L_VAL, r1)

	STORE_WORD(r2, GIO_OL_H, GIO_OL_H_VAL, r1)
	STORE_WORD(r2, GIO_OH_H, GIO_OH_H_VAL, r1)
	STORE_WORD(r2, GIO_E0_H, GIO_E0_H_VAL, r1)
	STORE_WORD(r2, GIO_E1_H, GIO_E1_H_VAL, r1)

	STORE_WORD(r2, GIO_OL_HH, GIO_OL_HH_VAL, r1)
	STORE_WORD(r2, GIO_OH_HH, GIO_OH_HH_VAL, r1)
	STORE_WORD(r2, GIO_E0_HH, GIO_E0_HH_VAL, r1)
	STORE_WORD(r2, GIO_E1_HH, GIO_E1_HH_VAL, r1)

	STORE_WORD(r2, GIO_OL_HHH, GIO_OL_HHH_VAL, r1)
	STORE_WORD(r2, GIO_OH_HHH, GIO_OH_HHH_VAL, r1)
	STORE_WORD(r2, GIO_E0_HHH, GIO_E0_HHH_VAL, r1)
	STORE_WORD(r2, GIO_E1_HHH, GIO_E1_HHH_VAL, r1)

	/* Set CHG */
/*	SET_BASEREG(r3, CHG_BASE) */

	STORE_WORD(r3, CHG_PINSEL_G00,  CHG_PINSEL_G00_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_G16,  CHG_PINSEL_G16_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_G32,  CHG_PINSEL_G32_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_G48,  CHG_PINSEL_G48_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_G64,  CHG_PINSEL_G64_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_G80,  CHG_PINSEL_G80_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_G96,  CHG_PINSEL_G96_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_G112, CHG_PINSEL_G112_VAL, r1)

	STORE_WORD(r3, CHG_PINSEL_SP0,  CHG_PINSEL_SP0_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_DTV,  CHG_PINSEL_DTV_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_SD0,  CHG_PINSEL_SD0_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_SD1,  CHG_PINSEL_SD1_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_IIC2, CHG_PINSEL_IIC2_VAL, r1)
	STORE_WORD(r3, CHG_PINSEL_REFCLKO, CHG_PINSEL_REFCLKO_VAL, r1)

	/* Set PullUp/PullDown */
	STORE_WORD(r3, CHG_PULL_G00,  CHG_PULL_G00_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G08,  CHG_PULL_G08_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G16,  CHG_PULL_G16_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G24,  CHG_PULL_G24_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G32,  CHG_PULL_G32_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G40,  CHG_PULL_G40_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G48,  CHG_PULL_G48_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G56,  CHG_PULL_G56_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G64,  CHG_PULL_G64_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G72,  CHG_PULL_G72_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G80,  CHG_PULL_G80_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G88,  CHG_PULL_G88_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G96,  CHG_PULL_G96_VAL,  r1)
	STORE_WORD(r3, CHG_PULL_G104, CHG_PULL_G104_VAL, r1)
	STORE_WORD(r3, CHG_PULL_G112, CHG_PULL_G112_VAL, r1)

	STORE_WORD(r3, CHG_PULL0, CHG_PULL0_VAL, r1)
	STORE_WORD(r3, CHG_PULL1, CHG_PULL1_VAL, r1)
	STORE_WORD(r3, CHG_PULL2, CHG_PULL2_VAL, r1)
	STORE_WORD(r3, CHG_PULL3, CHG_PULL3_VAL, r1)

	STORE_WORD(r3, CHG_CTRL_AB0_BOOT,  CHG_CTRL_AB0_BOOT_VAL, r1)
	STORE_WORD(r3, CHG_RST_CTRL,  CHG_RST_CTRL_VAL, r1)

	/* Set drive current */
	STORE_WORD(r3, CHG_DRIVE0, CHG_DRIVE0_H_VAL, r1)
	STORE_WORD(r3, CHG_DRIVE1, CHG_DRIVE1_H_VAL, r1)
	STORE_WORD(r3, CHG_DRIVE2, CHG_DRIVE2_H_VAL, r1)

	/* Release Reset */
	STORE_WORD(r0, ASMU_RESETREQ0ENA, ASMU_RESETREQ0ENA_VAL, r1)
	STORE_WORD(r0, ASMU_RESETREQ0, ASMU_RESETREQ0_VAL, r1)
	STORE_WORD(r0, ASMU_RESETREQ0ENA, 0x00000000, r1)
			
	STORE_WORD(r0, ASMU_RESETREQ1ENA, ASMU_RESETREQ1ENA_VAL, r1)
	STORE_WORD(r0, ASMU_RESETREQ1, ASMU_RESETREQ1_VAL, r1)
	STORE_WORD(r0, ASMU_RESETREQ1ENA, 0x00000000, r1)
	
	STORE_WORD(r0, ASMU_RESETREQ2ENA, ASMU_RESETREQ2ENA_VAL, r1)
	STORE_WORD(r0, ASMU_RESETREQ2, ASMU_RESETREQ2_VAL, r1)	
	STORE_WORD(r0, ASMU_RESETREQ2ENA, 0x00000000, r1)

	STORE_WORD(r0, ASMU_RESETREQ3ENA, ASMU_RESETREQ3ENA_VAL, r1)
	STORE_WORD(r0, ASMU_RESETREQ3, ASMU_RESETREQ3_VAL, r1)	
	STORE_WORD(r0, ASMU_RESETREQ3ENA, 0x00000000, r1)

#ifdef CONFIG_EM1_CPU_BOARD_ONLY
_spi_init:
	STORE_WORD(r0, ASMU_DIVSP0SCLK, ASMU_SP0CLK_12MHZ, r1)

	SET_BASEREG(r3, EM1_SPI0_BASE)
	STORE_WORD(r3, SP0_CONTROL, SP0_CTL_RST, r1)

	/* Wait 100us */
	ldr	r7, =0x2d00 	/* 230MHz (11500d) */
	bl	_delay

	STORE_WORD(r3, SP0_CONTROL, SP0_CTL_RST_FREE, r1)
	STORE_WORD(r3, SP0_MODE, SP0_MODE_CS0, r1)
	STORE_WORD(r3, SP0_POL, SP0_POL_CS0, r1)

	ldr	r1, [r3, #(SP0_CONTROL & 0xff)]
	ldr	r7, =SP0_CTL_CHK_EMP
	and	r1, r1, r7
	cmp	r1, r7
	bne	_set_normalA

	/* _spi_rw(r4:ctrl_bit(in), r5:wait_bit(in), r6:tx_data(in)) */
	/* write pwc R54 = 0x66 */
	mov	r4, #(SP0_CTL_WRT_ENA | SP0_CTL_START)
	mov	r5, #SP0_CTL_START
	ldr	r6, =PWC_R54_SET_W
	bl	_spi_rw

	/* tx/rx stop */
	STORE_WORD(r3, SP0_CONTROL, 0, r1)

	/* Wait 1200us */
	ldr	r7, =0x22000 	/* 230MHz (138000d) */
	bl	_delay

	/* read pwc R1 */
	mov	r4, #(SP0_CTL_WRT_ENA | SP0_CTL_RD_ENA | SP0_CTL_START)
	mov	r5, #(SP0_CTL_START | SP0_CTL_RX_EMP)
	ldr	r6, =PWC_R1_SET_R
	bl	_spi_rw

	/* read rx data */
	ldr	r7, [r3, #(SP0_RX_DATA & 0xff)]
	/* tx/rx stop */
	STORE_WORD(r3, SP0_CONTROL, 0, r1)

	/* check supplier */
	and	r7, r7, #PWC_R1_CHECK_BIT
	mov	r1, #PWC_R1_SUPPLY_VBUS
	cmp	r7, r1
	bne	_set_normalA

	/* LED0 ON */
	mov	r4, #(SP0_CTL_WRT_ENA | SP0_CTL_START)
	mov	r5, #SP0_CTL_START
	ldr	r6, =PWC_R28_SET_0
	bl	_spi_rw

	/* tx/rx stop */
	STORE_WORD(r3, SP0_CONTROL, 0, r1)

	/* write pwc R81 = 0x13 */
	mov	r4, #(SP0_CTL_WRT_ENA | SP0_CTL_START)
	mov	r5, #SP0_CTL_START
	ldr	r6, =PWC_R81_SET_W
	bl	_spi_rw

	/* tx/rx stop */
	STORE_WORD(r3, SP0_CONTROL, 0, r1)

	/* read pwc R81 */
	mov	r4, #(SP0_CTL_WRT_ENA | SP0_CTL_RD_ENA | SP0_CTL_START)
	mov	r5, #(SP0_CTL_START | SP0_CTL_RX_EMP)
	ldr	r6, =PWC_R81_SET_R
_wait_conversion:
	bl	_spi_rw

	/* read rx data */
	ldr	r7, [r3, #(SP0_RX_DATA & 0xff)]
	/* tx/rx stop */
	STORE_WORD(r3, SP0_CONTROL, 0, r1)

	and	r7, r7, #0x10
	cmp	r7, #0
	bne	_wait_conversion

	/* LED1 ON */
	mov	r4, #(SP0_CTL_WRT_ENA | SP0_CTL_START)
	mov	r5, #SP0_CTL_START
	ldr	r6, =PWC_R28_SET_1
	bl	_spi_rw

	/* tx/rx stop */
	STORE_WORD(r3, SP0_CONTROL, 0, r1)

	/* read pwc R84 */
	mov	r4, #(SP0_CTL_WRT_ENA | SP0_CTL_RD_ENA | SP0_CTL_START)
	mov	r5, #(SP0_CTL_START | SP0_CTL_RX_EMP)
	ldr	r6, =PWC_R84_SET_R
	bl	_spi_rw
	/* read rx data */
	ldr	r8, [r3, #(SP0_RX_DATA & 0xff)]
	/* tx/rx stop */
	STORE_WORD(r3, SP0_CONTROL, 0, r1)

	/* read pwc R83 */
	ldr	r6, =PWC_R83_SET_R
	bl	_spi_rw
	/* read rx data */
	ldr	r7, [r3, #(SP0_RX_DATA & 0xff)]
	/* tx/rx stop */
	STORE_WORD(r3, SP0_CONTROL, 0, r1)
	
	and	r7, r7, #0x03
	and	r8, r8, #0xff
	lsl	r5, r8, #2
	orr	r5, r5, r7
	mov	r6, #0x240	/* VBAT=3.6v */
	cmp	r5, r6
	bgt	_set_normalA

_set_normalB:
	mov	r1, #ASMU_CLK_MODE_SEL_NMB
	b	_change_sysclk

_set_normalA:
	mov	r1, #ASMU_CLK_MODE_SEL_NMA
	b	_change_sysclk

	/* r4: ctrl_bit(in), r5: wait_bit(in), r6: tx_data(in) */
_spi_rw:
	ldr	r1, [r3, #(SP0_CONTROL & 0xff)]
	ldr	r7, =SP0_CTL_CHK_EMP
	and	r1, r1, r7
	cmp	r1, r7
	bne	_set_normalA

	/* set tx data */
	str	r6, [r3, #(SP0_TX_DATA & 0xfff)]
	/* tx/rx start */
	str	r4, [r3, #(SP0_CONTROL & 0xfff)]
	/* wait rx/tx end */
_wait_rw_end:
	ldr	r1, [r3, #(SP0_CONTROL & 0xff)]
	and	r1, r1, r5
	cmp	r1, #0
	bne	_wait_rw_end
	mov	pc, lr

#if 0
_delay:
	sub	r7, r7, #1
	cmp	r7, #0
	bne	_delay
	mov	pc, lr
#endif

_change_sysclk:
	str	r1, [r0, #(ASMU_CLK_MODE_SEL & 0xfff)]
	lsl	r1, r1, #8
	/* Wait CLK_MODE_SEL until bit[11:8]==0x1 */
WAIT_MODE_STATUS:
	LOAD_WORD(r0, ASMU_CLK_MODE_SEL, r7)
	and	r7, r7, #0x00000f00
	cmp	r7, r1
	bne	WAIT_MODE_STATUS

#else
	/* Wait 100us */
	ldr	r7, =0x2d00 	/* 230MHz (11500d) */
	bl	_delay
#if 0
WAIT_100US:
	sub	r7, r7, #1
	cmp	r7, #0
	bne	WAIT_100US
#endif

	STORE_WORD(r0, ASMU_CLK_MODE_SEL, ASMU_CLK_MODE_SEL_NMA, r1)
	/* Wait CLK_MODE_SEL until bit[11:8]==0x1 */
WAIT_MODE_STATUS:
	LOAD_WORD(r0, ASMU_CLK_MODE_SEL, r7)
	and	r7, r7, #0x00000f00
	cmp	r7, #0x00000100
	bne	WAIT_MODE_STATUS
#endif

#ifdef CONFIG_EM1_PLL3_238MHZ
	/* change PLL3 Setting */
	STORE_WORD(r0, ASMU_PLL3CTRL1, ASMU_PLL3CTRL1_STANDBY, r1)
	STORE_WORD(r0, ASMU_PLL3CTRL0, ASMU_PLL3CTRL0_238MHZ, r1)
	STORE_WORD(r0, ASMU_PLL3CTRL1, ASMU_PLL3CTRL1_ACTIVE, r1)

	/* Wait 500us (need 800us before PLL3 use) */
	mov	r7, #0x00020000		/* 500MHz (125000d) */
	bl	_delay
#if 0
WAIT_500US:
	sub	r7, r7, #1
	cmp	r7, #0
	bne	WAIT_500US
#endif
#endif	/* change PLL3 Setting */
	
	/* Disable unused clock lines */
	STORE_WORD(r0, ASMU_GCLKCTRL0ENA, ASMU_GCLKCTRL0ENA_VAL, r1)
	STORE_WORD(r0, ASMU_GCLKCTRL0, ASMU_GCLKCTRL0_VAL, r1)
	STORE_WORD(r0, ASMU_GCLKCTRL0ENA, 0x00000000, r1)

	STORE_WORD(r0, ASMU_GCLKCTRL1ENA, ASMU_GCLKCTRL1ENA_VAL, r1)
	STORE_WORD(r0, ASMU_GCLKCTRL1, ASMU_GCLKCTRL1_VAL, r1)
	STORE_WORD(r0, ASMU_GCLKCTRL1ENA, 0x00000000, r1)

	STORE_WORD(r0, ASMU_GCLKCTRL2ENA, ASMU_GCLKCTRL2ENA_VAL, r1)
	STORE_WORD(r0, ASMU_GCLKCTRL2, ASMU_GCLKCTRL2_VAL, r1)
	STORE_WORD(r0, ASMU_GCLKCTRL2ENA, 0x00000000, r1)

	STORE_WORD(r0, ASMU_GCLKCTRL3ENA, ASMU_GCLKCTRL3ENA_VAL, r1)
	STORE_WORD(r0, ASMU_GCLKCTRL3, ASMU_GCLKCTRL3_VAL, r1)
	STORE_WORD(r0, ASMU_GCLKCTRL3ENA, 0x00000000, r1)

	STORE_WORD(r0, ASMU_GCLKCTRL4ENA, ASMU_GCLKCTRL4ENA_VAL, r1)
	STORE_WORD(r0, ASMU_GCLKCTRL4, ASMU_GCLKCTRL4_VAL, r1)
	STORE_WORD(r0, ASMU_GCLKCTRL4ENA, 0x00000000, r1)

	/* Enable Automatic Clock Control */
	STORE_WORD(r0, ASMU_AHBCLKCTRL0, ASMU_AHBCLKCTRL0_VAL, r1)
	STORE_WORD(r0, ASMU_AHBCLKCTRL1, ASMU_AHBCLKCTRL1_rmMEM_VAL, r1)
	STORE_WORD(r0, ASMU_APBCLKCTRL0, ASMU_APBCLKCTRL0_VAL, r1)
	STORE_WORD(r0, ASMU_APBCLKCTRL1, ASMU_APBCLKCTRL1_VAL, r1)
	STORE_WORD(r0, ASMU_APBCLKCTRL2, ASMU_APBCLKCTRL2_VAL, r1)
	STORE_WORD(r0, ASMU_CLKCTRL, ASMU_CLKCTRL_rmMEM_VAL, r1)
	STORE_WORD(r0, ASMU_CLKCTRL1, ASMU_CLKCTRL1_VAL, r1)

#if defined(CONFIG_EM1_BOARD_DKIT)
	/* --- Get HW Development Kit Configuration ---- */
	SET_BASEREG(r3, AB0_BASE)

	STORE_WORD(r3, AB0_CS3BASEADD, AB0_CS3BASEADD_VAL, r1)
	STORE_WORD(r3, AB0_CS3BITCOMP, AB0_CS3BITCOMP_VAL, r1)
	STORE_WORD(r3, AB0_CS3WAITCTRL, AB0_CS3WAITCTRL_VAL, r1)
	STORE_WORD(r3, AB0_CS3WAITCTRL_W, AB0_CS3WAITCTRL_W_VAL, r1)
	STORE_WORD(r3, AB0_CS3READCTRL, AB0_CS3READCTRL_VAL, r1)
	STORE_WORD(r3, AB0_CS3CONTROL, AB0_CS3CONTROL_VAL, r1)

#if 0	/* WAIT_100US after LAN RESET */
	/* Wait 2us */
	mov	r7, #0x0200	/* 500MHz (500d) */
WAIT_2US:
	sub	r7, r7, #1
	cmp	r7, #0
	bne	WAIT_2US
#endif

#ifdef CONFIG_EM1_CPU_BOARD_ONLY
	ldr	r6, =USE_HDK_VERSION
#else
	/* LAN unreset */
	STORE_WORD(r2, GIO_OL_H, GIO_LANRST_CLR, r1)

	SET_BASEREG(r3, SMSC9118_BASE)
	mov	r5, #E2P_READ_CFGIO
	mov	r6, #0
wait_e2p_busy:
	ldr	r1, [r3, #(E2P_CMD & 0xff)]
	and	r7, r1, #E2P_CMD_EPC_BUSY
	cmp	r7, #0x00000000
	bne	wait_e2p_busy
	and	r7, r1, #E2P_CMD_EPC_TIMEOUT
	cmp	r7, #0x00000000
	beq	write_e2p_addr
	str	r1, [r3, #(E2P_CMD & 0xff)]
	b	wait_e2p_busy

write_e2p_addr:
	and	r1, r1, #E2P_CMD_EPC_ADDR
	and	r7, r5, #E2P_CMD_EPC_ADDR
	cmp	r1, r7
	beq	read_e2p_data
	str	r5, [r3, #(E2P_CMD & 0xff)]
	b	wait_e2p_busy

read_e2p_data:
	ldr	r1, [r3, #(E2P_DATA & 0xff)]
	orr	r6, r6, r1
	cmp	r5, #E2P_READ_CFGCPU
	beq	read_e2p_end
	sub	r5, r5, #1
	lsl	r6, r6, #8
	b	wait_e2p_busy

read_e2p_end:
	and	r7, r6, #E2P_CFGCPU_MASK
	cmp	r7, #E2P_CFGCPU_MASK
	bne	store_sram
	and	r7, r6, #E2P_CFGPWC_MASK
	cmp	r7, #E2P_CFGPWC_MASK
	bne	store_sram
	and	r7, r6, #E2P_CFGIO_MASK
	cmp	r7, #E2P_CFGIO_MASK
	bne	store_sram
	mov	r6, #0
store_sram:
#endif
	SET_BASEREG(r3, SRAM_HWINFO_BOOT)
	str	r6, [r3, #0]
	/* --- Get HW Development Kit Configuration END ---- */
#endif

/* Initialize DDR */

	STORE_WORD(r0, ASMU_MEMCCLK270_SEL, ASMU_MEMCCLK270_SEL_VAL1, r1)

	SET_BASEREG(r2, MEMC_BASE)
	STORE_WORD(r2, MEMC_DDR_CONFIGT1, MEMC_DDR_CONFIGT1_VAL1, r1)
	/* Wait AUTO_CALIBRATE until bit1==0x1 */
WAIT_AUTO_CALIBRATE:	
	LOAD_WORD(r2, MEMC_DDR_CONFIGT1, r7)
	and	r7, r7, #0x00000002
	cmp	r7, #0x00000002
	bne	WAIT_AUTO_CALIBRATE
		
	LOAD_WORD(r2, MEMC_DDR_CONFIGT3, r4) /* r4 <= [MEMC_DDR_CONFIG3] */

	STORE_WORD(r2, MEMC_DDR_CONFIGT2,   MEMC_DDR_CONFIGT2_VAL, r1)
	STORE_WORD(r0, ASMU_MEMCCLK270_SEL, ASMU_MEMCCLK270_SEL_VAL2, r1)
	STORE_WORD(r2, MEMC_DDR_CONFIGT1,   MEMC_DDR_CONFIGT1_VAL2, r1)
	STORE_WORD(r2, MEMC_DDR_CONFIGF,    MEMC_DDR_CONFIGF_VAL, r1)
	STORE_WORD(r2, MEMC_DDR_CONFIGA1,   MEMC_DDR_CONFIGA1_VAL, r1)
	STORE_WORD(r2, MEMC_DDR_CONFIGA2,   MEMC_DDR_CONFIGA2_VAL, r1)
	STORE_WORD(r2, MEMC_DDR_CONFIGC2,   MEMC_DDR_CONFIGC2_VAL1, r1)

	/* Wait 200us */
	mov	r7, #0xc400 	/* 500MHz (50000d) */
	bl	_delay
#if 0
WAIT_200US:
	sub	r7, r7, #1
	cmp	r7, #0
	bne	WAIT_200US
#endif
#if defined(CONFIG_EM1_BOARD_DKIT)
	and	r7, r6, #E2P_CFGCPU_DDRC1
	cmp	r7, #E2P_CFGCPU_DDRC1_SETB
	beq	ddrc1_setb
	STORE_WORD(r2, MEMC_DDR_CONFIGC1, MEMC_DDR_CONFIGC1_SETA, r1)
	b	ddrc1_set_end
ddrc1_setb:
	STORE_WORD(r2, MEMC_DDR_CONFIGC1, MEMC_DDR_CONFIGC1_SETB, r1)
ddrc1_set_end:
#else
	STORE_WORD(r2, MEMC_DDR_CONFIGC1, MEMC_DDR_CONFIGC1_VAL, r1)
#endif
	STORE_WORD(r2, MEMC_DDR_CONFIGC2, MEMC_DDR_CONFIGC2_VAL2, r1)

	/* Wait MEMC_DDR_CONFIGC2 == 0x300 */
WAIT_MEMC_DDR_CONFIGC2:
	LOAD_WORD(r2, MEMC_DDR_CONFIGC2, r7)
	and	r7, r7, #0x00000100
	cmp	r7, #0x00000100
	bne	WAIT_MEMC_DDR_CONFIGC2

	SET_BASEREG(r5, MEMC_MRS_BASE)
	STORE_WORD(r5, MEMC_REQSCH, MEMC_REQSCH_VAL, r1)

	STORE_WORD(r2, MEMC_DDR_CONFIGC2, MEMC_DDR_CONFIGC2_VAL3, r1)

	/* refresh */
	STORE_WORD(r2, MEMC_DDR_CONFIGR1, MEMC_DDR_CONFIGR1_VAL, r1)
#if defined(CONFIG_EM1_BOARD_DKIT)
	and	r7, r6, #E2P_CFGCPU_DDRR2
	cmp	r7, #E2P_CFGCPU_DDRR2_SETB
	beq	ddrr2_setb
	STORE_WORD(r2, MEMC_DDR_CONFIGR2, MEMC_DDR_CONFIGR2_SETA, r1)
	b	ddrr2_set_end
ddrr2_setb:
	STORE_WORD(r2, MEMC_DDR_CONFIGR2, MEMC_DDR_CONFIGR2_SETB, r1)
ddrr2_set_end:
#else
	STORE_WORD(r2, MEMC_DDR_CONFIGR2, MEMC_DDR_CONFIGR2_VAL, r1)	/* Auto Self Refresh ON */
#endif
	STORE_WORD(r2, MEMC_DDR_CONFIGR3, MEMC_DDR_CONFIGR3_VAL, r1)	/* Auto Power Down ON */

	STORE_WORD(r0, ASMU_AHBCLKCTRL1, ASMU_AHBCLKCTRL1_VAL, r1)
	STORE_WORD(r0, ASMU_CLKCTRL, ASMU_CLKCTRL_VAL, r1)

	 /* Soft Auto Calibrate */
	/* str register value - start */
	SET_BASEREG(r7, 0xa000f000)
	str	r0, [r7, #0x00]
	str	r1, [r7, #0x04]
	str	r2, [r7, #0x08]
	str	r3, [r7, #0x0c]
	str	r4, [r7, #0x10]
	str	r5, [r7, #0x14]
	str	r6, [r7, #0x18]
	str	r8, [r7, #0x1c]
	str	r9, [r7, #0x20]
	str	r10, [r7, #0x24]
	str	r11, [r7, #0x2c]
	str	r12, [r7, #0x30]
	/* str register value -  end  */
	mov	r7, lr
	SET_BASEREG(r9, 0xa000f000)
	str	r7, [r9, #0x34]
	bl	auto_calibration
	SET_BASEREG(r9, 0xa000f000)
	ldr	r7, [r9, #0x34]
	mov	lr, r7
	/* ldr register value - start */
	SET_BASEREG(r7, 0xa000f000)
	ldr	r0, [r7, #0x00]
	ldr	r1, [r7, #0x04]
	ldr	r2, [r7, #0x08]
	ldr	r3, [r7, #0x0c]
	ldr	r4, [r7, #0x10]
	ldr	r5, [r7, #0x14]
	ldr	r6, [r7, #0x18]
	ldr	r8, [r7, #0x1c]
	ldr	r9, [r7, #0x20]
	ldr	r10, [r7, #0x24]
	ldr	r11, [r7, #0x2c]
	ldr	r12, [r7, #0x30]
	/* ldr register value -  end  */
	/* Soft Auto Calibrate */
#endif

#if !defined(EMXX_MINIBOOT)
	/* Initialize GIO interrupt */
	SET_BASEREG(r2, GIO_BASE)

	STORE_WORD(r2, GIO_IDS_L, GIO_IDS_L_VAL, r1)
	STORE_WORD(r2, GIO_GSW_L, GIO_GSW_L_VAL, r1)
	STORE_WORD(r2, GIO_IDT0_L, GIO_IDT0_L_VAL, r1)
	STORE_WORD(r2, GIO_IDT1_L, GIO_IDT1_L_VAL, r1)
	STORE_WORD(r2, GIO_IDT2_L, GIO_IDT2_L_VAL, r1)
	STORE_WORD(r2, GIO_IDT3_L, GIO_IDT3_L_VAL, r1)
	STORE_WORD(r2, GIO_IIR_L, GIO_IIR_L_VAL, r1)
	STORE_WORD(r2, GIO_IIA_L, GIO_IIA_L_VAL, r1)
	STORE_WORD(r2, GIO_IEN_L, GIO_IEN_L_VAL, r1)

	STORE_WORD(r2, GIO_IDS_H, GIO_IDS_H_VAL, r1)
	STORE_WORD(r2, GIO_GSW_H, GIO_GSW_H_VAL, r1)
	STORE_WORD(r2, GIO_IDT0_H, GIO_IDT0_H_VAL, r1)
	STORE_WORD(r2, GIO_IDT1_H, GIO_IDT1_H_VAL, r1)
	STORE_WORD(r2, GIO_IDT2_H, GIO_IDT2_H_VAL, r1)
	STORE_WORD(r2, GIO_IDT3_H, GIO_IDT3_H_VAL, r1)
	STORE_WORD(r2, GIO_IIR_H, GIO_IIR_H_VAL, r1)
	STORE_WORD(r2, GIO_IIA_H, GIO_IIA_H_VAL, r1)
	STORE_WORD(r2, GIO_IEN_H, GIO_IEN_H_VAL, r1)

	STORE_WORD(r2, GIO_IDS_HH, GIO_IDS_HH_VAL, r1)
	STORE_WORD(r2, GIO_GSW_HH, GIO_GSW_HH_VAL, r1)
	STORE_WORD(r2, GIO_IDT0_HH, GIO_IDT0_HH_VAL, r1)
	STORE_WORD(r2, GIO_IDT1_HH, GIO_IDT1_HH_VAL, r1)
	STORE_WORD(r2, GIO_IDT2_HH, GIO_IDT2_HH_VAL, r1)
	STORE_WORD(r2, GIO_IDT3_HH, GIO_IDT3_HH_VAL, r1)
	STORE_WORD(r2, GIO_IIR_HH, GIO_IIR_HH_VAL, r1)
	STORE_WORD(r2, GIO_IIA_HH, GIO_IIA_HH_VAL, r1)
	STORE_WORD(r2, GIO_IEN_HH, GIO_IEN_HH_VAL, r1)

	STORE_WORD(r2, GIO_IDS_HHH, GIO_IDS_HHH_VAL, r1)
	STORE_WORD(r2, GIO_GSW_HHH, GIO_GSW_HHH_VAL, r1)
	STORE_WORD(r2, GIO_IDT0_HHH, GIO_IDT0_HHH_VAL, r1)
	STORE_WORD(r2, GIO_IDT1_HHH, GIO_IDT1_HHH_VAL, r1)
	STORE_WORD(r2, GIO_IDT2_HHH, GIO_IDT2_HHH_VAL, r1)
	STORE_WORD(r2, GIO_IDT3_HHH, GIO_IDT3_HHH_VAL, r1)
	STORE_WORD(r2, GIO_IIR_HHH, GIO_IIR_HHH_VAL, r1)
	STORE_WORD(r2, GIO_IIA_HHH, GIO_IIA_HHH_VAL, r1)
	STORE_WORD(r2, GIO_IEN_HHH, GIO_IEN_HHH_VAL, r1)

	/* Async bridge setting address map */
	SET_BASEREG(r2, AB0_BASE)

	STORE_WORD(r2, AB0_CS0BASEADD, AB0_CS0BASEADD_VAL, r1)
	STORE_WORD(r2, AB0_CS0BITCOMP, AB0_CS0BITCOMP_VAL, r1)
	STORE_WORD(r2, AB0_CS0WAITCTRL, AB0_CS0WAITCTRL_VAL, r1)
	STORE_WORD(r2, AB0_CS0WAITCTRL_W, AB0_CS0WAITCTRL_W_VAL, r1)
	STORE_WORD(r2, AB0_CS0READCTRL, AB0_CS0READCTRL_VAL, r1)
	STORE_WORD(r2, AB0_CS0CONTROL, AB0_CS0CONTROL_VAL, r1)

	STORE_WORD(r2, AB0_CS1BASEADD, AB0_CS1BASEADD_VAL, r1)
	STORE_WORD(r2, AB0_CS1BITCOMP, AB0_CS1BITCOMP_VAL, r1)
	STORE_WORD(r2, AB0_CS1WAITCTRL, AB0_CS1WAITCTRL_VAL, r1)
	STORE_WORD(r2, AB0_CS1WAITCTRL_W, AB0_CS1WAITCTRL_W_VAL, r1)
	STORE_WORD(r2, AB0_CS1READCTRL, AB0_CS1READCTRL_VAL, r1)
	STORE_WORD(r2, AB0_CS1CONTROL, AB0_CS1CONTROL_VAL, r1)

	STORE_WORD(r2, AB0_CS2BASEADD, AB0_CS2BASEADD_VAL, r1)
	STORE_WORD(r2, AB0_CS2BITCOMP, AB0_CS2BITCOMP_VAL, r1)
	STORE_WORD(r2, AB0_CS2WAITCTRL, AB0_CS2WAITCTRL_VAL, r1)
	STORE_WORD(r2, AB0_CS2WAITCTRL_W, AB0_CS2WAITCTRL_W_VAL, r1)
	STORE_WORD(r2, AB0_CS2READCTRL, AB0_CS2READCTRL_VAL, r1)
	STORE_WORD(r2, AB0_CS2CONTROL, AB0_CS2CONTROL_VAL, r1)

#if !defined(CONFIG_EM1_BOARD_DKIT)
	STORE_WORD(r2, AB0_CS3BASEADD, AB0_CS3BASEADD_VAL, r1)
	STORE_WORD(r2, AB0_CS3BITCOMP, AB0_CS3BITCOMP_VAL, r1)
	STORE_WORD(r2, AB0_CS3WAITCTRL, AB0_CS3WAITCTRL_VAL, r1)
	STORE_WORD(r2, AB0_CS3WAITCTRL_W, AB0_CS3WAITCTRL_W_VAL, r1)
	STORE_WORD(r2, AB0_CS3READCTRL, AB0_CS3READCTRL_VAL, r1)
	STORE_WORD(r2, AB0_CS3CONTROL, AB0_CS3CONTROL_VAL, r1)
#endif

	STORE_WORD(r2, AB0_FLASHCOMSET, AB0_FLASHCOMSET_VAL, r1)

	/* use DDR cache */
	SET_BASEREG(r2, MEMC_SYSCACHE_BASE)	
	STORE_WORD(r2, MEMC_CACHE_MODE, MEMC_CACHE_MODE_VAL, r1)
	STORE_WORD(r2, MEMC_DEGFUN, MEMC_DEGFUN_VAL, r1)

	SET_BASEREG(r0, ASMU_S0_BASE)
	/* PLL Auto Frequency Change */
	STORE_WORD(r0, ASMU_AUTO_FRQ_MASK0, ASMU_AUTO_FRQ_MASK0_VAL, r1)
	STORE_WORD(r0, ASMU_AUTO_FRQ_MASK1, ASMU_AUTO_FRQ_MASK1_VAL, r1)
	STORE_WORD(r0, ASMU_AUTO_FRQ_MASK3, ASMU_AUTO_FRQ_MASK3_VAL, r1)
	STORE_WORD(r0, ASMU_DFS_HALFMODE, ASMU_DFS_HALFMODE_VAL, r1)
	STORE_WORD(r0, ASMU_AUTO_FRQ_CHANGE, ASMU_AUTO_FRQ_CHANGE_VAL, r1)

	STORE_WORD(r0, ASMU_LCD_FIFOTHRESHOLD, ASMU_LCD_FIFOTHRESHOLD_VAL, r1)
	STORE_WORD(r0, ASMU_DFS_FIFOMODE, ASMU_DFS_FIFOMODE_VAL, r1)

	STORE_WORD(r0, ASMU_PLL2CTRL0, ASMU_PLL2CTRL0_VAL, r1)
	STORE_WORD(r0, ASMU_PLL2CTRL1, ASMU_PLL2CTRL1_VAL, r1)
	STORE_WORD(r0, ASMU_PLLVDDWAIT, ASMU_PLLVDDWAIT_VAL, r1)
	STORE_WORD(r0, ASMU_PLLLOCKTIME, ASMU_PLLLOCKTIME_VAL, r1)

	/* Initialize SRAM */
	SET_BASEREG(r2, SRC_BASE)
	STORE_WORD(r2, SRC_MODE, SRC_MODE_VAL, r1)

	/* Set Wait Timing of Async Bus */
	STORE_WORD(r0, ASMU_AB1_U70WAITCTRL, ASMU_AB1_U70WAITCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_U71WAITCTRL, ASMU_AB1_U71WAITCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_U72WAITCTRL, ASMU_AB1_U72WAITCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_IICWAITCTRL, ASMU_AB1_IICWAITCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_SDIAWAITCTRL, ASMU_AB1_SDIAWAITCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_SDIBWAITCTRL, ASMU_AB1_SDIBWAITCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_SDICWAITCTRL, ASMU_AB1_SDICWAITCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_U70READCTRL, ASMU_AB1_U70READCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_U71READCTRL, ASMU_AB1_U71READCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_U72READCTRL, ASMU_AB1_U72READCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_IICREADCTRL, ASMU_AB1_IICREADCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_SDIAREADCTRL, ASMU_AB1_SDIAREADCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_SDIBREADCTRL, ASMU_AB1_SDIBREADCTRL_VAL, r1)
	STORE_WORD(r0, ASMU_AB1_SDICREADCTRL, ASMU_AB1_SDICREADCTRL_VAL, r1)

	/* Set Auto Control POWER SW */
	STORE_WORD(r0, ASMU_POWERSW_ACTRL_EN, ASMU_POWERSW_ACTRL_EN_VAL, r1)

	/* Set POWER Saving */
	STORE_WORD(r0, ASMU_AUTO_MODE_EN, ASMU_AUTO_MODE_EN_VAL, r1)
	STORE_WORD(r0, ASMU_NORMALC_DIV,  ASMU_NORMALC_DIV_VAL, r1)
	STORE_WORD(r0, ASMU_NORMALD_DIV,  ASMU_NORMALD_DIV_VAL, r1)

	STORE_WORD(r0, ASMU_ECONOMY_DIV,  ASMU_ECONOMY_DIV_VAL, r1)
	STORE_WORD(r0, ASMU_STANDBY_DIV,  ASMU_STANDBY_DIV_VAL, r1)
	STORE_WORD(r0, ASMU_POWERON_DIV,  ASMU_POWERON_DIV_VAL, r1)
	STORE_WORD(r0, ASMU_QR_CLKDIV,    ASMU_QR_CLKDIV_VAL, r1)

	STORE_WORD(r0, ASMU_PWRCNT, ASMU_PWRCNT_VAL, r1)

	/* Set Initial value to Secure interrupt mask (MSE) */
	SET_BASEREG(r2, AINT_BASE)
	STORE_WORD(r2, AINT_IT0_IENS0, AINT_IT0_IENS0_VAL, r1)
	STORE_WORD(r2, AINT_IT0_IENS1, AINT_IT0_IENS1_VAL, r1)
	STORE_WORD(r2, AINT_IT0_IENS2, AINT_IT0_IENS2_VAL, r1)

#if 0	/* Power SW Control  Setting temporary step */
	/* Power SW Control */

	STORE_WORD(r0, ASMU_LOG2SW_ACTRLEN, ASMU_LOG2SW_ACTRLEN_VAL, r1)

	/* Wait  until bit16==0x0 */
WAIT_L2_PWRSW_STATUS:
	LOAD_WORD(r0, ASMU_LOG2SW_ACTRL, r7)
	and	r7, r7, #0x00010000
	cmp	r7, #0x00000000
	bne	WAIT_L2_PWRSW_STATUS

	STORE_WORD(r0, ASMU_LOG3SW_ACTRLEN, ASMU_LOG3SW_ACTRLEN_VAL, r1)

	/* Wait  until bit16==0x0 */
WAIT_L3_PWRSW_STATUS:
	LOAD_WORD(r0, ASMU_LOG3SW_ACTRL, r7)
	and	r7, r7, #0x00010000
	cmp	r7, #0x00000000
	bne	WAIT_L3_PWRSW_STATUS
#else	/* Power SW Control  Setting temporary step */
	/* L3 off sequence */
	STORE_WORD(r0, ASMU_LOG3SW_ACTRLEN, ASMU_LOG3SW_ACTRLEN_VAL, r1)

	STORE_WORD(r0, ASMU_L3_POWERSW_BUZ, ASMU_L3_POWERSW_BUZ_VAL_1, r1)
	STORE_WORD(r0, ASMU_L3_POWERSW_BUZ, ASMU_L3_POWERSW_BUZ_VAL_2, r1)
	STORE_WORD(r0, ASMU_L3_POWERSW_BUZ, ASMU_L3_POWERSW_BUZ_VAL_3, r1)
	STORE_WORD(r0, ASMU_L3_POWERSW_BUZ, ASMU_L3_POWERSW_BUZ_VAL_4, r1)
	STORE_WORD(r0, ASMU_L3_POWERSW_BUZ, ASMU_L3_POWERSW_BUZ_VAL_5, r1)
	STORE_WORD(r0, ASMU_L3_POWERSW_BUZ, ASMU_L3_POWERSW_BUZ_VAL_6, r1)
	STORE_WORD(r0, ASMU_L3_POWERSW_BUZ, ASMU_L3_POWERSW_BUZ_VAL_7, r1)
	STORE_WORD(r0, ASMU_L3_POWERSW_BUZ, ASMU_L3_POWERSW_BUZ_VAL_8, r1)
	STORE_WORD(r0, ASMU_L3_POWERSW_BUZ, ASMU_L3_POWERSW_BUZ_VAL_9, r1)
#endif	/* Power SW Control  Setting temporary step */

	STORE_WORD(r0, ASMU_POWERSW_ENA, ASMU_POWERSW_ENA_VAL, r1)

	/* Set LCD_LCLOCK DIV */
	STORE_WORD(r0, ASMU_DIVLCDLCLK, ASMU_DIVLCDLCLK_VAL, r1)

	/* Select USB New Core */
	STORE_WORD(r0, ASMU_SEL_BIGWEST, ASMU_SEL_BIGWEST_VAL, r1)

	/* Setting AXI Bus */
	SET_BASEREG(r2, AXI_BASE)
	STORE_WORD(r2, AXI_LAZY_LOCK, AXI_LAZY_LOCK_VAL, r1)

	mrc	p15, 0, r0, c1, c0, 0
	bic	r0, r0, #0x1000	//disable instraction cache
	mcr	p15, 0, r0, c1, c0, 0
#endif	/* !defined(EMXX_MINIBOOT) */

	mov	pc, r9

